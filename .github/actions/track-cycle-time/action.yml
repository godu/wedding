name: Track Cycle Time
description: Computes cycle time for specified issues

inputs:
  project-token:
    description: 'GitHub token with project permissions'
    required: true
  project-number:
    description: 'GitHub Project number'
    required: true
  issues:
    description: 'JSON array of issue numbers to track (optional, falls back to parsing commits)'
    required: false
    default: ''
  cycle-time-field:
    description: 'Name of the Number field to store cycle time'
    required: false
    default: 'Cycle Time'
  reset-columns:
    description: 'Comma-separated list of columns that reset the cycle time (issue goes back to planning)'
    required: false
    default: 'Backlog,Todo'
  work-columns:
    description: 'Comma-separated list of columns that start the cycle time (work begins)'
    required: false
    default: 'In Progress,In Review,Deployed in Staging,Deployed in Production'

runs:
  using: composite
  steps:
    - name: Compute and set cycle time ⏱️
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.project-token }}
        script: |
          const projectNumber = parseInt('${{ inputs.project-number }}');
          const issuesInput = '${{ inputs.issues }}';
          const owner = context.repo.owner;
          const repo = context.repo.repo;
          const cycleTimeFieldName = '${{ inputs.cycle-time-field }}';
          const resetColumns = '${{ inputs.reset-columns }}'.split(',').map(s => s.trim());
          const workColumns = '${{ inputs.work-columns }}'.split(',').map(s => s.trim());

          // Get issue numbers: from input or parse commits
          let issueNumbers;
          if (issuesInput && issuesInput !== '[]') {
            issueNumbers = JSON.parse(issuesInput);
            console.log(`Using provided issues: ${issueNumbers.join(', ')}`);
          } else {
            // Fallback: parse commits
            const commits = context.payload.commits || [];
            const pattern = /(?:fix|fixes|fixed|close|closes|closed|resolve|resolves|resolved)\s*#(\d+)/gi;
            const parsed = new Set();
            for (const commit of commits) {
              let match;
              while ((match = pattern.exec(commit.message)) !== null) {
                parsed.add(parseInt(match[1]));
              }
            }
            issueNumbers = [...parsed];
            console.log(`Parsed from commits: ${issueNumbers.join(', ') || 'none'}`);
          }

          if (issueNumbers.length === 0) {
            console.log('No issues to track');
            return;
          }

          // Get project with cycle time field
          const projectQuery = `
            query($owner: String!, $number: Int!, $cycleTimeFieldName: String!) {
              user(login: $owner) {
                projectV2(number: $number) {
                  id
                  cycleTimeField: field(name: $cycleTimeFieldName) {
                    ... on ProjectV2Field { id }
                  }
                }
              }
            }
          `;

          const projectData = await github.graphql(projectQuery, { owner, number: projectNumber, cycleTimeFieldName });
          const project = projectData.user.projectV2;
          const cycleTimeField = project.cycleTimeField;

          if (!cycleTimeField) {
            console.log(`"${cycleTimeFieldName}" field not found in project. Please create a Number field with this name.`);
            return;
          }

          const today = new Date();

          for (const issueNumber of issueNumbers) {
            try {
              // Get issue's project item and timeline
              const issueQuery = `
                query($owner: String!, $repo: String!, $number: Int!, $cycleTimeFieldName: String!) {
                  repository(owner: $owner, name: $repo) {
                    issue(number: $number) {
                      projectItems(first: 10) {
                        nodes {
                          id
                          project { id }
                          cycleTime: fieldValueByName(name: $cycleTimeFieldName) {
                            ... on ProjectV2ItemFieldNumberValue {
                              number
                            }
                          }
                        }
                      }
                      timelineItems(first: 100, itemTypes: [PROJECT_V2_ITEM_STATUS_CHANGED_EVENT]) {
                        nodes {
                          ... on ProjectV2ItemStatusChangedEvent {
                            createdAt
                            previousStatus
                            status
                            project { id }
                          }
                        }
                      }
                    }
                  }
                }
              `;

              const issueData = await github.graphql(issueQuery, { owner, repo, number: issueNumber, cycleTimeFieldName });
              const issue = issueData.repository.issue;

              const projectItem = issue.projectItems.nodes.find(item => item.project.id === project.id);

              if (!projectItem) {
                console.log(`Issue #${issueNumber} is not in the project`);
                continue;
              }

              // Skip if cycle time already set
              if (projectItem.cycleTime?.number !== undefined) {
                console.log(`Issue #${issueNumber} already has Cycle Time: ${projectItem.cycleTime.number} days`);
                continue;
              }

              // Find status changes for our project (sorted chronologically)
              const statusChanges = issue.timelineItems.nodes
                .filter(event => event.project?.id === project.id)
                .sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));

              if (statusChanges.length === 0) {
                console.log(`Issue #${issueNumber} has no status change history`);
                continue;
              }

              // Find the effective start time by iterating through history
              // Reset if issue moves back to Backlog/Todo
              let startedAt = null;
              for (const event of statusChanges) {
                if (resetColumns.includes(event.status)) {
                  startedAt = null;
                } else if (workColumns.includes(event.status) && !startedAt) {
                  startedAt = event.createdAt;
                }
              }

              if (!startedAt) {
                console.log(`Issue #${issueNumber} was never moved to a work column`);
                continue;
              }

              const startDate = new Date(startedAt);
              const cycleTime = Math.round((today - startDate) / (1000 * 60 * 60 * 24) * 100) / 100;

              // Update Cycle Time field
              const mutation = `
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $number: Float!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId
                    itemId: $itemId
                    fieldId: $fieldId
                    value: { number: $number }
                  }) {
                    projectV2Item { id }
                  }
                }
              `;

              await github.graphql(mutation, {
                projectId: project.id,
                itemId: projectItem.id,
                fieldId: cycleTimeField.id,
                number: cycleTime
              });

              console.log(`Issue #${issueNumber}: Started ${startedAt}, Cycle Time = ${cycleTime} days`);

            } catch (error) {
              console.log(`Failed to track issue #${issueNumber}: ${error.message}`);
            }
          }
