name: Track Cycle Time
description: Computes cycle time for specified issues

inputs:
  project-token:
    description: 'GitHub token with project permissions'
    required: true
  project-number:
    description: 'GitHub Project number'
    required: true
  issues:
    description: 'JSON array of issue numbers to track (optional, falls back to parsing commits)'
    required: false
    default: ''
  cycle-time-field:
    description: 'Name of the Number field to store cycle time'
    required: false
    default: 'Cycle Time'
  reset-columns:
    description: 'Comma-separated list of columns that reset the cycle time (issue goes back to planning)'
    required: false
    default: 'Backlog,Todo'
  work-columns:
    description: 'Comma-separated list of columns that start the cycle time (work begins)'
    required: false
    default: 'In Progress,In Review,Deployed in Staging,Deployed in Production'
  work-day-start:
    description: 'Start hour of working day (0-23)'
    required: false
    default: '9'
  work-day-end:
    description: 'End hour of working day (0-23)'
    required: false
    default: '18'
  timezone:
    description: 'IANA timezone for working hours (e.g., Europe/Paris, America/New_York)'
    required: false
    default: 'UTC'

runs:
  using: composite
  steps:
    - name: Compute and set cycle time ⏱️
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.project-token }}
        script: |
          const projectNumber = parseInt('${{ inputs.project-number }}');
          const issuesInput = '${{ inputs.issues }}';
          const owner = context.repo.owner;
          const repo = context.repo.repo;
          const cycleTimeFieldName = '${{ inputs.cycle-time-field }}';
          const resetColumns = '${{ inputs.reset-columns }}'.split(',').map(s => s.trim());
          const workColumns = '${{ inputs.work-columns }}'.split(',').map(s => s.trim());
          const workDayStart = parseInt('${{ inputs.work-day-start }}');
          const workDayEnd = parseInt('${{ inputs.work-day-end }}');
          const timezone = '${{ inputs.timezone }}';

          // Get issue numbers: from input or parse commits
          let issueNumbers;
          if (issuesInput && issuesInput !== '[]') {
            issueNumbers = JSON.parse(issuesInput);
            console.log(`Using provided issues: ${issueNumbers.join(', ')}`);
          } else {
            // Fallback: parse commits
            const commits = context.payload.commits || [];
            const pattern = /(?:fix|fixes|fixed|close|closes|closed|resolve|resolves|resolved)\s*#(\d+)/gi;
            const parsed = new Set();
            for (const commit of commits) {
              let match;
              while ((match = pattern.exec(commit.message)) !== null) {
                parsed.add(parseInt(match[1]));
              }
            }
            issueNumbers = [...parsed];
            console.log(`Parsed from commits: ${issueNumbers.join(', ') || 'none'}`);
          }

          if (issueNumbers.length === 0) {
            console.log('No issues to track');
            return;
          }

          // Get project with cycle time field
          const projectQuery = `
            query($owner: String!, $number: Int!, $cycleTimeFieldName: String!) {
              user(login: $owner) {
                projectV2(number: $number) {
                  id
                  cycleTimeField: field(name: $cycleTimeFieldName) {
                    ... on ProjectV2Field { id }
                  }
                }
              }
            }
          `;

          const projectData = await github.graphql(projectQuery, { owner, number: projectNumber, cycleTimeFieldName });
          const project = projectData.user.projectV2;
          const cycleTimeField = project.cycleTimeField;

          if (!cycleTimeField) {
            console.log(`"${cycleTimeFieldName}" field not found in project. Please create a Number field with this name.`);
            return;
          }

          const today = new Date();

          // Timezone helpers using Intl.DateTimeFormat
          function getPartsInTimezone(date, tz) {
            const formatter = new Intl.DateTimeFormat('en-US', {
              timeZone: tz,
              year: 'numeric',
              month: '2-digit',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit',
              second: '2-digit',
              hour12: false,
              weekday: 'short'
            });
            const parts = {};
            for (const { type, value } of formatter.formatToParts(date)) {
              parts[type] = value;
            }
            return parts;
          }

          function getDayInTimezone(date, tz) {
            const parts = getPartsInTimezone(date, tz);
            const days = { Sun: 0, Mon: 1, Tue: 2, Wed: 3, Thu: 4, Fri: 5, Sat: 6 };
            return days[parts.weekday];
          }

          function getHourInTimezone(date, tz) {
            const parts = getPartsInTimezone(date, tz);
            return parseInt(parts.hour);
          }

          function getMinuteInTimezone(date, tz) {
            const parts = getPartsInTimezone(date, tz);
            return parseInt(parts.minute);
          }

          // Get UTC timestamp for a specific hour on the same calendar day in timezone
          function getTimeInTimezone(date, tz, hour, minute = 0) {
            const parts = getPartsInTimezone(date, tz);
            const dateStr = `${parts.year}-${parts.month}-${parts.day}T${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}:00`;
            // Parse as if in target timezone by finding the offset
            const tempDate = new Date(dateStr + 'Z');
            const tempParts = getPartsInTimezone(tempDate, tz);
            const tempHour = parseInt(tempParts.hour);
            const tempMinute = parseInt(tempParts.minute);
            const offsetMs = ((tempHour - hour) * 60 + (tempMinute - minute)) * 60 * 1000;
            return new Date(tempDate.getTime() - offsetMs);
          }

          // Get next midnight in timezone
          function getNextMidnightInTimezone(date, tz) {
            const parts = getPartsInTimezone(date, tz);
            const nextDay = new Date(`${parts.year}-${parts.month}-${parts.day}T00:00:00Z`);
            nextDay.setUTCDate(nextDay.getUTCDate() + 1);
            return getTimeInTimezone(nextDay, tz, 0, 0);
          }

          // Count working days between two dates (excludes weekends and non-working hours)
          // O(1) implementation with fractional day support
          function countWorkingDays(startDate, endDate) {
            const start = new Date(startDate);
            const end = new Date(endDate);

            if (end <= start) return 0;

            const msPerHour = 1000 * 60 * 60;
            const msPerDay = msPerHour * 24;
            const workHoursPerDay = workDayEnd - workDayStart;

            // Helper: get working ms for a single day given time range
            function getWorkingMsForDay(dayStart, dayEnd) {
              const dayOfWeek = getDayInTimezone(dayStart, timezone);
              if (dayOfWeek === 0 || dayOfWeek === 6) return 0; // Weekend

              const workStart = getTimeInTimezone(dayStart, timezone, workDayStart);
              const workEnd = getTimeInTimezone(dayStart, timezone, workDayEnd);

              const overlapStart = Math.max(dayStart.getTime(), workStart.getTime());
              const overlapEnd = Math.min(dayEnd.getTime(), workEnd.getTime());

              return Math.max(0, overlapEnd - overlapStart);
            }

            // Step 1: Full weeks (O(1))
            const totalMs = end - start;
            const totalDays = totalMs / msPerDay;
            const fullWeeks = Math.floor(totalDays / 7);
            const workingMsPerWeek = 5 * workHoursPerDay * msPerHour;
            let totalWorkingMs = fullWeeks * workingMsPerWeek;

            // Step 2: Remainder days (max 7 iterations = O(1))
            const remainderStart = new Date(start.getTime() + fullWeeks * 7 * msPerDay);
            let current = new Date(remainderStart);

            while (current < end) {
              const nextMidnight = getNextMidnightInTimezone(current, timezone);
              const dayEnd = nextMidnight < end ? nextMidnight : end;

              totalWorkingMs += getWorkingMsForDay(current, dayEnd);
              current = nextMidnight;
            }

            // Return as fraction of working days
            return totalWorkingMs / (workHoursPerDay * msPerHour);
          }

          for (const issueNumber of issueNumbers) {
            try {
              // Get issue's project item and timeline
              const issueQuery = `
                query($owner: String!, $repo: String!, $number: Int!, $cycleTimeFieldName: String!) {
                  repository(owner: $owner, name: $repo) {
                    issue(number: $number) {
                      projectItems(first: 10) {
                        nodes {
                          id
                          project { id }
                          cycleTime: fieldValueByName(name: $cycleTimeFieldName) {
                            ... on ProjectV2ItemFieldNumberValue {
                              number
                            }
                          }
                        }
                      }
                      timelineItems(first: 100, itemTypes: [PROJECT_V2_ITEM_STATUS_CHANGED_EVENT]) {
                        nodes {
                          ... on ProjectV2ItemStatusChangedEvent {
                            createdAt
                            previousStatus
                            status
                            project { id }
                          }
                        }
                      }
                    }
                  }
                }
              `;

              const issueData = await github.graphql(issueQuery, { owner, repo, number: issueNumber, cycleTimeFieldName });
              const issue = issueData.repository.issue;

              const projectItem = issue.projectItems.nodes.find(item => item.project.id === project.id);

              if (!projectItem) {
                console.log(`Issue #${issueNumber} is not in the project`);
                continue;
              }

              // Skip if cycle time already set
              if (projectItem.cycleTime?.number !== undefined) {
                console.log(`Issue #${issueNumber} already has Cycle Time: ${projectItem.cycleTime.number} days`);
                continue;
              }

              // Find status changes for our project (sorted chronologically)
              const statusChanges = issue.timelineItems.nodes
                .filter(event => event.project?.id === project.id)
                .sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));

              if (statusChanges.length === 0) {
                console.log(`Issue #${issueNumber} has no status change history`);
                continue;
              }

              // Find the effective start time by iterating through history
              // Reset if issue moves back to Backlog/Todo
              let startedAt = null;
              for (const event of statusChanges) {
                if (resetColumns.includes(event.status)) {
                  startedAt = null;
                } else if (workColumns.includes(event.status) && !startedAt) {
                  startedAt = event.createdAt;
                }
              }

              if (!startedAt) {
                console.log(`Issue #${issueNumber} was never moved to a work column`);
                continue;
              }

              const startDate = new Date(startedAt);
              const cycleTime = parseFloat(countWorkingDays(startDate, today).toFixed(2));

              // Update Cycle Time field
              const mutation = `
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $number: Float!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId
                    itemId: $itemId
                    fieldId: $fieldId
                    value: { number: $number }
                  }) {
                    projectV2Item { id }
                  }
                }
              `;

              await github.graphql(mutation, {
                projectId: project.id,
                itemId: projectItem.id,
                fieldId: cycleTimeField.id,
                number: cycleTime
              });

              console.log(`Issue #${issueNumber}: Started ${startedAt}, Cycle Time = ${cycleTime} days`);

            } catch (error) {
              console.log(`Failed to track issue #${issueNumber}: ${error.message}`);
            }
          }
